<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="../styles/prism.css">
  <script src="/main.js" defer></script>
  <script src="../scripts/prism.js" defer></script>
</head>
<body>
  <h1>Деструктуризация</h1>
  <a href="../index.html">назад</a>
  <p>Деструктуризация — синтаксический сахар для «вынимания» значений из массивов и объектов и присвоения их переменным в одном выражении. Делает код короче, чище и выразительнее — особенно при работе с API-ответами, props в React, возвращаемыми кортежами и т.д.</p>
  <h2>Синтаксис</h2>
  <h3>Массивы (array destructuring)</h3>
<pre>
  <code class="lang-js">
    const arr = [10, 20, 30];
    const [a, b, c] = arr;
    console.log(a, b, c); // 10 20 30

    // Пропуск элементов
    const [, second] = arr;
    console.log(second); // 20

    // Остаток (rest) — только в конце
    const [first, ...rest] = arr;
    console.log(first, rest); // 10 [20, 30]

    // Поменять переменные местами (удобно)
    let x = 1, y = 2;
    [x, y] = [y, x];
    // x = 2, y = 1
  </code>
</pre>
  <h3>Объекты (object destructuring)</h3>
<pre>
  <code class="lang-js">
    const user = { id: 42, name: 'John', age: 30 };

    // Простое извлечение по имени свойства
    const { id, name } = user;
    // id = 42, name = 'John'

    // Переименование при извлечении
    const { id: userId, age: years } = user;
    // userId = 42, years = 30

    // Значения по умолчанию (используются только если свойство === undefined)
    const { country = 'RU' } = user;
  </code>
</pre>
  <h2>Деструктуризация в присваивании существующим переменным</h2>
  <p>Если ты присваиваешь объект в уже объявленные переменные, нужно обернуть левую часть в скобки — иначе JS решит, что это блок.</p>
<pre>
  <code class="lang-js">
    let a, b;
    ({ a, b } = { a: 1, b: 2 });
  </code>
</pre>
  <h2>Rest и Spread — отличие и применение</h2>
  <ul>
    <li>...rest в деструктуризации собирает оставшиеся элементы/свойства:</li>
<pre>
  <code class="lang-js">
    const { a, ...rest } = { a: 1, b: 2, c: 3 };
    // rest = { b: 2, c: 3 }
  </code>
</pre>
    <li>Spread (...) в литералах создаёт копию:</li>
<pre>
  <code class="lang-js">
    const copy = { ...obj, extra: 5 }; // новый объект
  </code>
</pre>
    <li>В объектной деструктуризации ...rest содержит только own enumerable свойства (не берёт прототипные и не включает символы по умолчанию).</li>
  </ul>
  <h2>Практические примеры из работы</h2>
  <h3>A. React — props и хуки</h3>
<pre>
  <code class="lang-js">
    // Functional component: props destructuring
    function UserCard({ user: { id, name, avatar }, onClick }) {
      return (
        &lt;div onClick={() => onClick(id)}>
          &lt;img src={avatar} alt={name} />
          &lt;h2>{name}&lt;/h2>
        &lt;/div>
      );
    }

    // useState / useReducer — array destructuring
    const [count, setCount] = useState(0);
    const [state, dispatch] = useReducer(reducer, initialState);
  </code>
</pre>
  <h3>B. API: извлечение нужных полей из ответа</h3>
<pre>
  <code class="lang-js">
    // Предположим, fetch возвращает объект { data: { user: { id, name }}, meta: {...} }
    const res = await fetch('/api/user/42');
    const json = await res.json();

    const { data: { user: { id, name } = {} } = {}, meta } = json;
    // Теперь id и name безопасно получены — если data или user нет, ошибки не будет
  </code>
</pre>
  <h3>C. Express / route handler — параметры и query</h3>
<pre>
  <code class="lang-js">
    app.get('/search', (req, res) => {
      const { q = '', page = '1' } = req.query;
      // дальше преобразовать page в число, валидация и т.д.
    });
  </code>
</pre>
  <h3>D. Object.entries / Map</h3>
<pre>
  <code class="lang-js">
    const map = new Map([['a', 1], ['b', 2]]);
    for (const [key, value] of map) {
      console.log(key, value);
    }

    // Обход объекта:
    for (const [k, v] of Object.entries({x:1, y:2})) {
      // k = 'x', v = 1
    }
  </code>
</pre>
  <h2>Вывод:</h2>
  <ul>
    <li>Массив: <code>[a, b, ...rest] = arr</code></li>
    <li>Объект: <code>{ a, b: alias, c = 5, ...rest } = obj</code></li>
    <li>Дефолт с пустым объектом в аргументах функции: <code>fn({x, y} = {})</code></li>
    <li>Переименование: <code>{ oldName: newName }</code></li>
    <li>Rest должен быть последним</li>
    <li>Дефолты срабатывают только при <code>undefined</code></li>
    <li>Присваивание в существующие переменные: <code>({a, b} = obj)</code></li>
  </ul>
</body>
</html>